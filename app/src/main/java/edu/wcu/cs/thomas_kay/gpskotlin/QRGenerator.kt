package edu.wcu.cs.thomas_kay.gpskotlin

import android.Manifest
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.os.Build
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.os.Environment
import android.util.Log
import android.view.WindowManager
import android.widget.Button
import android.widget.EditText
import android.widget.ImageView
import android.widget.Toast
import androidmads.library.qrgenearator.QRGContents
import androidmads.library.qrgenearator.QRGEncoder
import androidx.annotation.RequiresApi
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import java.io.BufferedOutputStream
import java.io.File
import java.io.FileNotFoundException
import java.io.FileOutputStream
import java.io.IOException

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 AndroidMad / Mushtaq M A
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * @author Thomas Kay
 * @version 5/9/2024
 *
 * Activity to generate a QR code and to save it within an user's device.
 */

/** Result code for external storage permission */
const val RESULT_CODE_WRITE = 102
/** Identifier required for QR codes generated by the app */
const val TITLE = "WCUTrails"
class QRGenerator : AppCompatActivity() {

    /** Encoder used to create QR code */
    private lateinit var encoder:QRGEncoder
    /** Bitmap used to store QR code */
    private lateinit var bitmap:Bitmap
    /** Imageview that displays the generated QR code */
    private lateinit var qr:ImageView
    /** Edittext used to receive data for QR code */
    private lateinit var editText: EditText
    /** Boolean to check if the QR code can be saved into the user's device */
    private var canSave = false

    /**
     * Sets up activity and checks if external storage permission is granted.
     */
    @RequiresApi(Build.VERSION_CODES.R)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_qrgenerator)
        checkPermission()
        this.qr = findViewById(R.id.qr_image)
        val create:Button = findViewById(R.id.create_qr)
        create.setOnClickListener { createQR() }
        val save:Button = findViewById(R.id.save_qr)
        save.setOnClickListener { saveQR() }
        this.editText = findViewById(R.id.user_input)
    }

    /**
     * Checks if the user's external storage permission has been granted to the application.
     */
    private fun checkPermission() {
        if(ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) !=
            PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, arrayOf(
                Manifest.permission.WRITE_EXTERNAL_STORAGE), RESULT_CODE_WRITE)
        }
    }

    /**
     * Checks if user agreed to grant permission to use its external storage.
     *
     * If the external storage permission is not enabled, exits out of activity.
     */
    override fun onRequestPermissionsResult(
        requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if(grantResults[0] == PackageManager.PERMISSION_GRANTED) {
            Toast.makeText(this, "Write to external storage granted",Toast.LENGTH_LONG).show()
        } else {
            finish()
        }
    }

    /**
     * Generates QR code with data provided by the edittext.
     *
     * Only generates QR code if the data is valid.
     */
    @RequiresApi(Build.VERSION_CODES.R)
    private fun createQR() {
        val data = editText.text.toString()
        // QR code cannot be generated if the edittext is empty
        if(data.isEmpty()) {
            Toast.makeText(this, "Cannot create QR code with no data", Toast.LENGTH_LONG).show()
            return
        }
        val dataArray = data.split(" ")
        Log.v("test", data)
        Log.v("test", "${dataArray.size}")
        for(i in dataArray) {
            Log.v("array memeber", i)
        }
        when {
            // QR code is invalid if its format is invalid
            dataArray.size != 3 -> {
                Toast.makeText(this,"Invalid amount of lines of data; must be 3 lines of data",
                    Toast.LENGTH_LONG).show()
            }
            // QR code is invalid if its first element isn't the unique identifier
            dataArray[0] != TITLE -> {
                Toast.makeText(this, "Invalid header; must be $TITLE", Toast.LENGTH_LONG).show()
            }
            // QR code is invalid if the data for the lat and long are not correct
            !isLatOrLng(dataArray[1]) || !isLatOrLng(dataArray[2]) -> {
                Toast.makeText(this, "Invalid data; latitude and longitude values must be doubles",
                    Toast.LENGTH_LONG).show()
            }
            else -> {
                val window = getSystemService(WINDOW_SERVICE) as WindowManager
                val dimen = window.currentWindowMetrics.bounds
                var size = dimen.width()
                if(dimen.width() >= dimen.height()) {
                    size = dimen.height()
                }
                size = size * 3/4
                val encryptedData = encodeQR(data)
                // Generates QR code and sets up QR code to the image view
                this.encoder = QRGEncoder(encryptedData, QRGContents.Type.TEXT, size)
                encoder.colorBlack = ContextCompat.getColor(this, R.color.gps_color)
                this.bitmap = this.encoder.bitmap
                this.qr.setImageBitmap(this.bitmap)
                // Can now save QR code data
                this.canSave = true
            }
        }
    }

    /**
     * Saves QR code into the user's external storage.
     */
    private fun saveQR() {
        when {
            // Cannot save if no QR code has been generated yet
            !this.canSave -> {
                Toast.makeText(this, "Cannot save if QR code is not created yet",
                    Toast.LENGTH_LONG).show()
            }
            // Cannot save if the user has not enabled permission for external storage
            !isExternalWritable() -> {
                Toast.makeText(this, "Cannot save without mounted media", Toast.LENGTH_LONG).show()
            }
            else -> {
                try {
                    val path = Environment.getExternalStoragePublicDirectory(
                        Environment.DIRECTORY_PICTURES
                    )
                    val fileName = String.format("QRcode%d.jpeg", System.currentTimeMillis())
                    val file = File(path, fileName)
                    val outputStream = BufferedOutputStream(FileOutputStream(file))
                    this.bitmap.compress(Bitmap.CompressFormat.JPEG, QUALITY, outputStream)
                    outputStream.flush()
                    outputStream.close()
                    Toast.makeText(this, "QR code has been successfully saved",
                        Toast.LENGTH_LONG).show()
                } catch(e:FileNotFoundException) {
                    Toast.makeText(this, "${e.message}", Toast.LENGTH_LONG).show()
                } catch(e:IOException) {
                    Toast.makeText(this, "${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }

    /**
     * Checks if the text represents a latitude/longitude value.
     *
     * @param data String that is being checked to see if data is a latitude/longitude value.
     * @return True if the data is a latitude/longitude value.
     */
    private fun isLatOrLng(data:String):Boolean {
        var isDouble = true
        try {
            data.toDouble()
        } catch(e:NumberFormatException) {
            isDouble = false
        }
        return isDouble
    }

    /**
     * Checks if the user granted permission for external writable storage.
     */
    private fun isExternalWritable():Boolean {
        val state = Environment.getExternalStorageState()!!
        if(Environment.MEDIA_MOUNTED == state) {
            return true
        }
        return false
    }

}